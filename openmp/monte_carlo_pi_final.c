#include <omp.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#define SEED 42
#define nthreads 1

int main(int argc, char* argv)
{
    double start_time = omp_get_wtime();

    int niter = 50000000;  /* # of iterations */
    double x, y;  /* x and y coordinates */
    int i, tid, count = 0;  /* # of points in the 1st quadrant of unit circle */
    double z;  /* Distance from original */
    double pi;  /* Estimated pi value */
    srand(SEED);  /* Initialize random number generator; srand is used to seed the random number generated by rand() */

    #pragma omp parallel for private(x,y,z,tid) reduction(+:count) num_threads(nthreads)
    /* Initialize OpenMP parallel for with reduction(âˆ‘) */

    for (i = 0; i < niter; i++) {
        /* Randomly generate a number and divide it by the max possible, so we get a ratio between 0 and 1 */
        x = (double)rand() / RAND_MAX;
        y = (double)rand() / RAND_MAX;
        z = (x * x + y * y);  /* Calculate the diagonal */

        if (z <= 1) count++;  /* Assume the square's length of side (and also the circle's radius) is 1 */
        /* Check if it lies within the circle; if yes then increment count */

        /* Each of the following if statements is printing out the result of a specific thread */
/*        if (i==(niter/8)-1) {
            tid = omp_get_thread_num();
            printf(" thread %i just did iteration %i the count is %i\n",tid,i,count);
        }
        if (i==(2*niter/8)-1) {
            tid = omp_get_thread_num();
            printf(" thread %i just did iteration %i the count is %i\n",tid,i,count);
        }
        if (i==(3*niter/8)-1) {
            tid = omp_get_thread_num();
            printf(" thread %i just did iteration %i the count is %i\n",tid,i,count);
        }
        if (i==(4*niter/8)-1) {
            tid = omp_get_thread_num();
            printf(" thread %i just did iteration %i the count is %i\n",tid,i,count);
        }
        if (i==(5*niter/8)-1) {
            tid = omp_get_thread_num();
            printf(" thread %i just did iteration %i the count is %i\n",tid,i,count);
        }
        if (i==(6*niter/8)-1) {
            tid = omp_get_thread_num();
            printf(" thread %i just did iteration %i the count is %i\n",tid,i,count);
        }
        if (i==(7*niter/8)-1) {
            tid = omp_get_thread_num();
            printf(" thread %i just did iteration %i the count is %i\n",tid,i,count);
        }
        if (i==(8*niter/8)-1) {
            tid = omp_get_thread_num();
            printf(" thread %i just did iteration %i the count is %i\n",tid,i,count);
        }
*/
    }

    printf( "The total count is: %i \n", count);
    pi = (double)count / niter * 4;  /* Calculate PI based on the aggregate count of the points that lie within the circle */
    printf("# of trials = %d, estimate of pi is %g \n", niter, pi);
    double time = omp_get_wtime() - start_time;  /* To get the run time */
    printf("# of threads = %d, run time is %f \n", nthreads, time);
    return 0;
}

